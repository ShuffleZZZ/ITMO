# Blocking Stack
В этом задании вам необходимо реализовать алгоритм стека, 
в котором операция `pop` является блокирующейся в случае вызова на пустом стеке, 
аналогично операции `dequeue` в блокирующейся очереди. Все заблокированные запросы должны
обрабатываться в порядке очереди (first-come first-served).

Мы будем реализовывать этот алгоритм для корутин, использую соответствующий механизм 
для засыпания и пробуждения. Смотрите класс `BlockingStackSequential` 
в [`BlockingStackTest.kt`](test/BlockingStackTest.kt) в качестве примера.

В файле [`src/BlockingStack.kt`](src/BlockingStack.kt) находится описание интерфейса блокирующегося стека, 
который  вам необходимо реализовать. Ваше решение должно быть в файле [`src/BlockingStackImpl.kt`](src/BlockingStackImpl.kt).
Используйте классы `j.u.c.atomic.AtomicXXX` для хранения разделяемых между потоками переменных.

Реализация этого стека очень похожа на алгоритм семафора, расказанный на лекции. 
Предлагается хранить счетчик количества элементов (отрицательные значения обозначают количество ждущих операций `pop`),
который обновляется в начале операции. В качестве очереди потоков предлагается использовать ту же конструкцию 
с односвязным списком сегментов, что и в семафоре, с той лишь разницей, что `suspend` возвращает элемент, 
который был передан в соответствующий вызов `resume`. Сам стек нужно хранить в виде односвязного списка 
(вспоминаем одно из первых домашних заданий). 

В случае, если `pop` увидел, что по значению счетчика в стеке есть элементы, 
а на самом деле их еще нет (произошла гонка), то можно записать в стек специальное значение 
`SUSPENDED` и пойти спать; таким образом, операция `push` увидит, 
что стек хранит `SUSPENDED` и пойдёт будить `pop` вместо записи элемента в стек.

Основная синхронизация должна быть lock-free.

Для проверки вашего решения запустите из корня репозитория:
* `./gradlew build` на Linux или MacOS
* `gradlew build` на Windows